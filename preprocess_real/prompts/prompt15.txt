
Your task is to select EXACTLY the context parts needed to implement the test scenarios for the provided code.

**Rules:**
1. Analyze the code under test and test scenarios carefully
2. Select context parts that contain:
   - Data structures, required for implementing test scenarios
   - Functions / methods of classes, required for implementing test scenarios
   - Any other information, required for implementing test scenarios
3. Exclude:
   - Unrelated components (even if similar)
   - Low-level implementation details
   - Duplicate information
4. Return ONLY Python list of selected part numbers, like [1, 3, 4]

**Code to test:**
package com.commerce.backend.service;
@Service
public class TokenServiceImpl implements TokenService {
    private static final int EXPIRY_DATE = 60 * 24;
    private final UserService userService;
    private final PasswordEncoder passwordEncoder;
    private final ApplicationEventPublisher eventPublisher;
    private final VerificationTokenRepository verificationTokenRepository;
    private final PasswordForgotTokenRepository passwordForgotTokenRepository;
    @Autowired
    public TokenServiceImpl(UserService userService,
                            PasswordEncoder passwordEncoder,
                            ApplicationEventPublisher eventPublisher,
                            VerificationTokenRepository verificationTokenRepository,
                            PasswordForgotTokenRepository passwordForgotTokenRepository) {
        this.userService = userService;
        this.passwordEncoder = passwordEncoder;
        this.eventPublisher = eventPublisher;
        this.verificationTokenRepository = verificationTokenRepository;
        this.passwordForgotTokenRepository = passwordForgotTokenRepository;
    }
    @Override
    public void createEmailConfirmToken(User user) {
        String token = UUID.randomUUID().toString();
        VerificationToken verificationToken = new VerificationToken();
        verificationToken.setToken(token);
        verificationToken.setUser(user);
        verificationToken.setExpiryDate(calculateExpiryDate());
        verificationTokenRepository.save(verificationToken);
        eventPublisher.publishEvent(new OnRegistrationCompleteEvent(user, token));
    }
    @Override
    public void createPasswordResetToken(String email) {
        User user = userService.findByEmail(email);
        if (Objects.isNull(user)) {
            return;
        }

        PasswordForgotToken passwordForgotToken = passwordForgotTokenRepository.findByUser(user)
                .orElse(null);
        if (Objects.isNull(passwordForgotToken)) {
            passwordForgotToken = new PasswordForgotToken();
            passwordForgotToken.setUser(user);
        }

        String token = UUID.randomUUID().toString();
        passwordForgotToken.setToken(token);
        passwordForgotToken.setExpiryDate(calculateExpiryDate());
        passwordForgotTokenRepository.save(passwordForgotToken);

        eventPublisher.publishEvent(new OnPasswordForgotRequestEvent(user, token));
    }
    @Override
    public void validateEmail(String token) {
        VerificationToken verificationToken = verificationTokenRepository.findByToken(token)
                .orElseThrow(() -> new ResourceNotFoundException("Null verification token"));


        User user = verificationToken.getUser();

        if (Objects.isNull(user)) {
            throw new ResourceNotFoundException("User not found");
        }

        checkTokenExpire(verificationToken.getExpiryDate());

        user.setEmailVerified(1);
        verificationTokenRepository.delete(verificationToken);
        userService.saveUser(user);
    }
    @Override
    public void validateForgotPasswordConfirm(String token) {
        PasswordForgotToken passwordForgotToken = passwordForgotTokenRepository.findByToken(token)
                .orElseThrow(() -> new ResourceNotFoundException("Token not found"));

        checkTokenExpire(passwordForgotToken.getExpiryDate());
    }
    @Override
    public void validateForgotPassword(PasswordForgotValidateRequest passwordForgotValidateRequest) {
        PasswordForgotToken passwordForgotToken = passwordForgotTokenRepository.findByToken(passwordForgotValidateRequest.getToken())
                .orElseThrow(() -> new ResourceNotFoundException("Token not found"));

        User user = passwordForgotToken.getUser();

        if (Objects.isNull(user)) {
            throw new ResourceNotFoundException("User not found");
        }

        checkTokenExpire(passwordForgotToken.getExpiryDate());

        if (passwordEncoder.matches(passwordForgotValidateRequest.getNewPassword(), user.getPassword())) {
            return;
        }

        user.setPassword(passwordEncoder.encode(passwordForgotValidateRequest.getNewPassword()));
        userService.saveUser(user);
        passwordForgotTokenRepository.delete(passwordForgotToken);
    }
    private Date calculateExpiryDate() {
        Calendar cal = Calendar.getInstance();
        cal.setTime(new Timestamp(cal.getTime().getTime()));
        cal.add(Calendar.MINUTE, TokenServiceImpl.EXPIRY_DATE);
        return new Date(cal.getTime().getTime());
    }
    private void checkTokenExpire(Date date) {
        if ((date.getTime() - Calendar.getInstance().getTime().getTime()) <= 0) {
            throw new InvalidArgumentException("Token is expired");
        }

    }
}

**Test scenarios (5 total):**
0) Verify that the system creates an email confirmation token and publishes a registration complete event when provided a valid user
Steps: Given a registered user exists with an unverified email
When the system is requested to create an email confirmation token for that user
Then a unique token should be generated with an appropriate expiry date
And the token should be saved in the verification token repository
And a registration complete event should be published with the generated token

1) Verify that the system creates a password reset token and publishes a password forgot event when a valid email is provided
Steps: Given a registered user exists with a valid email address
When the system is requested to create a password reset token for that email
Then the user should be retrieved from the system
And a unique password reset token should be generated with a proper expiry date
And the token should be saved in the password reset token repository
And a password forgot request event should be published with the generated token

2) Verify that no password reset token is created when a non-existing email is provided
Steps: Given no user exists in the system with the provided email address
When the system is requested to create a password reset token for that email
Then the system should not generate any token
And no password reset token should be saved
And no password forgot request event should be published

3) Verify that the system validates an email confirmation token by marking the email as verified and deleting the token
Steps: Given a valid email confirmation token exists and is linked to a registered user
When the system is requested to validate the email using the token
Then the system should confirm that the token has not expired
And the userâ€™s email verification flag should be updated to verified
And the email confirmation token should be removed from the repository
And the updated user information should be saved

4) Verify that the system updates the user's password when a valid forgot password token is provided with a new password different from the current one
Steps: Given a valid, non-expired password reset token exists linked to a registered user
And a password reset request is prepared with a new password that does not match the current password
When the system is requested to update the password using the forgot password validation process
Then the system should confirm that the token has not expired
And the new password should be encoded and set for the user
And the updated user information should be saved
And the used password reset token should be deleted from the repository



**Context parts (0-32):**

=== Part 0 ===
package com.commerce.backend.service;
public interface UserService {
    User saveUser(User user)
    User findByEmail(String email)
}

=== Part 1 ===
package com.commerce.backend.service;
@Service
public class UserServiceImpl implements UserService {
    @Autowired
    public UserServiceImpl(UserRepository userRepository,
                           PasswordEncoder passwordEncoder,
                           UserResponseConverter userResponseConverter)
}

=== Part 2 ===
package org.springframework.security.crypto.password;
public interface PasswordEncoder {
    java.lang.String encode(java.lang.CharSequence charSequence)
    boolean matches(java.lang.CharSequence charSequence, java.lang.String s)
}

=== Part 3 ===
package com.commerce.backend.dao;
@Repository
public interface VerificationTokenRepository extends CrudRepository<VerificationToken, Long> {
    Optional<VerificationToken> findByToken(String token)
}

=== Part 4 ===
package com.commerce.backend.dao;
@Repository
public interface PasswordForgotTokenRepository extends CrudRepository<PasswordForgotToken, Long> {
    Optional<PasswordForgotToken> findByToken(String token)
    Optional<PasswordForgotToken> findByUser(User user)
}

=== Part 5 ===
Class `com.commerce.backend.model.entity.User` declaration:
@Entity
@Table(name = "user")
public class User
The class uses the following imports:
- from package com.commerce.backend.model.entity: Cart
The class has following members:
public methods:
- User()
- void setId(Long id)
- void setCart(Cart cart)
- void setEmail(String email)
- void setPassword(String password)
- void setFirstName(String firstName)
- void setLastName(String lastName)
- void setCity(String city)
- void setState(String state)
- void setZip(String zip)
- void setEmailVerified(Integer emailVerified)
- void setRegistrationDate(Date registrationDate)
- void setPhone(String phone)
- void setCountry(String country)
- void setAddress(String address)
fields:
- @Column(name = "email_verified")
    private Integer emailVerified;
- @Column(name = "password")
    private String password;


=== Part 6 ===
Class `com.commerce.backend.model.request.user.PasswordForgotValidateRequest` declaration:
@PasswordMatches
public class PasswordForgotValidateRequest
The class has following members:
public methods:
- PasswordForgotValidateRequest()
- void setToken(String token)
- void setNewPassword(String newPassword)
- void setNewPasswordConfirm(String newPasswordConfirm)
fields:
- @NotBlank
    private String token;
- @NotBlank
    @Size(min = 6, max = 52)
    private String newPassword;


=== Part 7 ===
package com.commerce.backend.dao;
@Repository
public interface UserRepository extends CrudRepository<User, Long> {
}

=== Part 8 ===
package com.commerce.backend.converter.user;
@Component
public class UserResponseConverter implements Function<User, UserResponse> {
}

=== Part 9 ===
Class `com.commerce.backend.model.entity.Cart` declaration:
@Entity
@Table(name = "cart")
public class Cart
The class uses the following imports:
- from package com.commerce.backend.model.entity: Discount, CartItem, User
The class has following members:
public methods:
- Cart()
- void setId(Long id)
- void setUser(User user)
- void setCartItemList(List<CartItem> cartItemList)
- void setDiscount(Discount discount)
- void setTotalCartPrice(Float totalCartPrice)
- void setTotalCargoPrice(Float totalCargoPrice)
- void setTotalPrice(Float totalPrice)
- void setDateCreated(Date dateCreated)


=== Part 10 ===
Class `CartItem` declaration:
@Entity
@Table(name = "cart_item")
public class CartItem
The class uses the following imports:
- from package com.commerce.backend.model.entity: ProductVariant, Cart
The class has following members:
public methods:
- CartItem()
- void setId(Long id)
- void setCart(Cart cart)
- void setProductVariant(ProductVariant productVariant)
- void setAmount(Integer amount)


=== Part 11 ===
Class `com.commerce.backend.model.entity.Discount` declaration:
@Entity
@Table(name = "discount")
public class Discount
The class uses the following imports:
- from package com.commerce.backend.model.entity: Cart, Order
The class has following members:
public methods:
- Discount()
- void setId(Long id)
- void setOrderList(List<Order> orderList)
- void setCartList(List<Cart> cartList)
- void setCode(String code)
- void setDiscountPercent(Integer discountPercent)
- void setStatus(Integer status)


=== Part 12 ===
Class `ProductVariant` declaration:
@Entity
@Table(name = "product_variant")
public class ProductVariant
The class uses the following imports:
- from package com.commerce.backend.model.entity: Color, Product
The class has following members:
public methods:
- ProductVariant()
- void setId(Long id)
- void setProduct(Product product)
- void setColor(Color color)
- void setWidth(String width)
- void setHeight(String height)
- void setComposition(String composition)
- void setPrice(Float price)
- void setCargoPrice(Float cargoPrice)
- void setTaxPercent(Float taxPercent)
- void setImage(String image)
- void setThumb(String thumb)
- void setStock(Integer stock)
- void setSellCount(Integer sellCount)
- void setLive(Integer live)


=== Part 13 ===
Class `com.commerce.backend.model.entity.Order` declaration:
@Entity
@Table(name = "orders")
public class Order
The class uses the following imports:
- from package com.commerce.backend.model.entity: Discount, OrderDetail, User
The class has following members:
public methods:
- Order()
- void setId(Long id)
- void setUser(User user)
- void setOrderDetailList(List<OrderDetail> orderDetailList)
- void setDiscount(Discount discount)
- void setShipName(String shipName)
- void setShipAddress(String shipAddress)
- void setBillingAddress(String billingAddress)
- void setCity(String city)
- void setState(String state)
- void setZip(String zip)
- void setCountry(String country)
- void setPhone(String phone)
- void setTotalPrice(Float totalPrice)
- void setTotalCargoPrice(Float totalCargoPrice)
- void setDate(Date date)
- void setShipped(Integer shipped)
- void setCargoFirm(String cargoFirm)
- void setTrackingNumber(String trackingNumber)


=== Part 14 ===
Class `com.commerce.backend.model.entity.Product` declaration:
@Entity
@Table(name = "product")
public class Product
The class uses the following imports:
- from package com.commerce.backend.model.entity: ProductVariant, ProductCategory
The class has following members:
public methods:
- Product()
- void setId(Long id)
- void setProductCategory(ProductCategory productCategory)
- void setProductVariantList(List<ProductVariant> productVariantList)
- void setSku(String sku)
- void setName(String name)
- void setUrl(String url)
- void setLongDesc(String longDesc)
- void setDateCreated(Date dateCreated)
- void setLastUpdated(Date lastUpdated)
- void setUnlimited(Integer unlimited)


=== Part 15 ===
Class `com.commerce.backend.model.entity.Color` declaration:
@Entity
@Table(name = "color")
public class Color
The class uses the following imports:
- from package com.commerce.backend.model.entity: ProductVariant
The class has following members:
public methods:
- Color()
- void setId(Long id)
- void setProductVariantList(List<ProductVariant> productVariantList)
- void setName(String name)
- void setHex(String hex)


=== Part 16 ===
Class `OrderDetail` declaration:
@Entity
@Table(name = "order_detail")
public class OrderDetail
The class uses the following imports:
- from package com.commerce.backend.model.entity: ProductVariant, Order
The class has following members:
public methods:
- OrderDetail()
- void setId(Long id)
- void setOrder(Order order)
- void setProductVariant(ProductVariant productVariant)
- void setAmount(Integer amount)


=== Part 17 ===
package com.commerce.backend.model.entity;
@Entity
@Table(name = "product_category")
public class ProductCategory {
public ProductCategory()
public void setId(java.lang.Long id)
public void setName(java.lang.String name)
}

=== Part 18 ===
package com.commerce.backend.service;
public interface TokenService {
}

=== Part 19 ===
package com.commerce.backend.model.entity;
@Entity
@Table(name = "verification_token")
public class VerificationToken {
    @Column(name = "token")
    private String token;
    @OneToOne(fetch = FetchType.EAGER)
    @JoinColumn(nullable = false, name = "user_id")
    private User user;
    @Column(name = "expiry_date")
    private Date expiryDate;
}

=== Part 20 ===
package com.commerce.backend.model.event;
public class OnRegistrationCompleteEvent extends ApplicationEvent {
    private User user;
    private String token;
    public OnRegistrationCompleteEvent(User user, String token) {
        super(user);
        this.user = user;
        this.token = token;
    }
}

=== Part 21 ===
package com.commerce.backend.model.entity;
@Entity
@Table(name = "password_reset_token")
public class PasswordForgotToken {
    @Column(name = "token")
    private String token;
    @OneToOne(fetch = FetchType.EAGER)
    @JoinColumn(nullable = false, name = "user_id")
    private User user;
    @Column(name = "expiry_date")
    private Date expiryDate;
}

=== Part 22 ===
package com.commerce.backend.model.event;
public class OnPasswordForgotRequestEvent extends ApplicationEvent {
    private User user;
    private String token;
    public OnPasswordForgotRequestEvent(User user, String token) {
        super(user);
        this.user = user;
        this.token = token;
    }
}

=== Part 23 ===
package com.commerce.backend.error.exception;
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String s) { super(s); }
}

=== Part 24 ===
package javax.persistence;
@java.lang.annotation.Documented
@java.lang.annotation.Target({java.lang.annotation.ElementType.TYPE})
@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface Entity {
}

=== Part 25 ===
package javax.persistence;
@java.lang.annotation.Target({java.lang.annotation.ElementType.TYPE})
@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface Table {
    java.lang.String name() default ""
}

=== Part 26 ===
package javax.persistence;
@java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.FIELD})
@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface Column {
    java.lang.String name() default ""
}

=== Part 27 ===
package javax.persistence;
@java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.FIELD})
@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface OneToOne {
    javax.persistence.FetchType fetch() default javax.persistence.FetchType.EAGER
}

=== Part 28 ===
package javax.persistence;
public enum FetchType {
 EAGER
}

=== Part 29 ===
package javax.persistence;
@java.lang.annotation.Repeatable(javax.persistence.JoinColumns.class)
@java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.FIELD})
@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface JoinColumn {
    java.lang.String name() default ""
    boolean nullable() default true
}

=== Part 30 ===
package com.commerce.backend.error.exception;
public class InvalidArgumentException extends RuntimeException {
    public InvalidArgumentException(String s) { super(s); }
}

=== Part 31 ===
package com.commerce.backend.validator;
@Target({TYPE, ANNOTATION_TYPE})
@Retention(RUNTIME)
@Constraint(validatedBy = PasswordMatchesValidator.class)
@Documented
public @interface PasswordMatches {
}

=== Part 32 ===
package com.commerce.backend.validator;
public class PasswordMatchesValidator implements ConstraintValidator<PasswordMatches, Object> {
}


Remember: Your response MUST be ONLY the list, e.g. [1, 3, 5]

Your task is to select EXACTLY the context parts needed to implement the test scenarios for the provided code.

**Rules:**
1. Analyze the code under test and test scenarios carefully
2. Select context parts that contain:
   - Data structures, required for implementing test scenarios
   - Functions / methods of classes, required for implementing test scenarios
   - Any other information, required for implementing test scenarios
3. Exclude:
   - Unrelated components (even if similar)
   - Low-level implementation details
   - Duplicate information
4. Return ONLY Python list of selected part numbers, like [1, 3, 4]

**Code to test:**
package com.commerce.backend.api;
@RestController
public class CartController extends ApiController {
    private final CartService cartService;
    @Autowired
    public CartController(CartService cartService) {
        this.cartService = cartService;
    }
    @PostMapping(value = "/cart")
    public ResponseEntity<CartResponse> addToCart(@RequestBody @Valid AddToCartRequest addToCartRequest) {
        CartResponse cartResponse = cartService.addToCart(addToCartRequest.getProductVariantId(), addToCartRequest.getAmount());
        return new ResponseEntity<>(cartResponse, HttpStatus.OK);
    }
    @PostMapping(value = "/cart/increment")
    public ResponseEntity<CartResponse> increaseCartItem(@RequestBody @Valid IncrementCartItemRequest incrementCartItemRequest) {
        CartResponse cartResponse = cartService.incrementCartItem(incrementCartItemRequest.getCartItemId(), incrementCartItemRequest.getAmount());
        return new ResponseEntity<>(cartResponse, HttpStatus.OK);
    }
    @PostMapping(value = "/cart/decrement")
    public ResponseEntity<CartResponse> decreaseCartItem(@RequestBody @Valid DecrementCartItemRequest decrementCartItemRequest) {
        CartResponse cartResponse = cartService.decrementCartItem(decrementCartItemRequest.getCartItemId(), decrementCartItemRequest.getAmount());
        return new ResponseEntity<>(cartResponse, HttpStatus.OK);
    }
    @GetMapping(value = "/cart")
    public ResponseEntity<CartResponse> fetchCart() {
        CartResponse cartResponse = cartService.fetchCart();
        return new ResponseEntity<>(cartResponse, HttpStatus.OK);
    }
    @PostMapping(value = "/cart/remove")
    public ResponseEntity<CartResponse> removeFromCart(@RequestBody @Valid RemoveFromCartRequest removeFromCartRequest) {
        CartResponse cartResponse = cartService.removeFromCart(removeFromCartRequest.getCartItemId());
        return new ResponseEntity<>(cartResponse, HttpStatus.OK);
    }
    @DeleteMapping(value = "/cart")
    public ResponseEntity<HttpStatus> emptyCart() {
        cartService.emptyCart();
        return new ResponseEntity<>(HttpStatus.OK);
    }
    @PostMapping(value = "/cart/confirm")
    public ResponseEntity<Boolean> confirmCart(@RequestBody @Valid ConfirmCartRequest confirmCartRequest) {
        Boolean confirmCart = cartService.confirmCart(confirmCartRequest);
        return new ResponseEntity<>(confirmCart, HttpStatus.OK);
    }
}

**Test scenarios (7 total):**
0) Verify that a valid product variant and quantity can be added to the cart successfully
Steps: Given a registered customer with an active session
And the customer has selected a valid product variant with available stock
When the customer adds the item to the cart with a specified quantity greater than zero
Then the system should acknowledge the request with a successful response
And the cart details should include the newly added item with the correct quantity

1) Verify that an existing cart item quantity is increased correctly
Steps: Given a customer who already has an item in the cart with an initial quantity
When the customer requests to increase the quantity of the cart item by a valid amount
Then the system should update the cart item quantity accordingly
And the updated quantity should be reflected in the cart details

2) Verify that an existing cart item quantity is decreased correctly without going below one
Steps: Given a customer with an item in the cart that has a quantity greater than one
When the customer requests to decrease the quantity of the cart item by a valid amount
Then the system should reduce the quantity of the item in the cart
And the updated cart details should show the new quantity ensuring it does not fall below the minimum limit

3) Verify that the cart details can be fetched and display the current items and totals
Steps: Given a customer with several items added to the cart
When the customer fetches the cart details
Then the system should return the current state of the cart including each itemâ€™s details
And the overall totals such as total cart price, cargo price, and any discounts should be correctly computed

4) Verify that a specific cart item can be removed from the cart successfully
Steps: Given a customer with multiple items in the cart including the target item for removal
When the customer sends a request to remove the selected item from the cart
Then the system should remove the specified item from the cart
And the cart details should no longer include the removed item while maintaining the other items intact

5) Verify that the cart can be completely emptied in a single operation
Steps: Given a customer whose cart contains one or more items
When the customer sends a request to empty the cart
Then the system should remove all items from the cart
And the cart should be updated to an empty state with a successful response status

6) Verify that the cart can be confirmed with applied details including discounts and total prices
Steps: Given a customer with valid items in the cart and appropriate cart details ready for checkout
When the customer sends a confirmation request with details such as cart items, discount information, and calculated totals
Then the system should validate the cart confirmation details
And the confirmation response should indicate that the cart has been successfully confirmed for checkout



**Context parts (0-59):**

=== Part 0 ===
package org.springframework.samples.petclinic.customers.web;
@ResponseStatus(value = HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) { super(message); }
}

=== Part 1 ===
package com.commerce.backend.service.cache;
@Service
@CacheConfig(cacheNames = "product_variant")
public class ProductVariantCacheServiceImpl implements ProductVariantCacheService {
    @Autowired
    public ProductVariantCacheServiceImpl(ProductVariantRepository productVariantRepository)
}

=== Part 2 ===
package com.commerce.backend.dao;
@Repository
public interface ProductRepository extends PagingAndSortingRepository<Product, Long> {
}

=== Part 3 ===
package jakarta.persistence;
@java.lang.annotation.Repeatable(jakarta.persistence.JoinColumns.class)
@java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.FIELD})
@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface JoinColumn {
    java.lang.String name() default ""
}

=== Part 4 ===
package com.commerce.backend.converter.cart;
@Component
public class CartResponseConverter implements Function<Cart, CartResponse> {
}

=== Part 5 ===
package org.springframework.security.crypto.password;
public interface PasswordEncoder {
}

=== Part 6 ===
package com.commerce.backend.converter.product;
@Component
public class ProductDetailsResponseConverter implements Function<Product, ProductDetailsResponse> {
}

=== Part 7 ===
package org.springframework.web.reactive.function.client;
public interface WebClient {
    org.springframework.web.reactive.function.client.WebClient.RequestHeadersUriSpec<?> get()
    static interface Builder {
        org.springframework.web.reactive.function.client.WebClient build()
    }
    static interface RequestHeadersUriSpec <S extends org.springframework.web.reactive.function.client.WebClient.RequestHeadersSpec<S>> extends org.springframework.web.reactive.function.client.WebClient.UriSpec<S>, org.springframework.web.reactive.function.client.WebClient.RequestHeadersSpec<S> {
    }
    static interface ResponseSpec {
        <T> reactor.core.publisher.Mono<T> bodyToMono(java.lang.Class<T> elementClass)
    }
    static interface RequestHeadersSpec <S extends org.springframework.web.reactive.function.client.WebClient.RequestHeadersSpec<S>> {
        org.springframework.web.reactive.function.client.WebClient.ResponseSpec retrieve()
    }
    static interface UriSpec <S extends org.springframework.web.reactive.function.client.WebClient.RequestHeadersSpec<?>> {
        S uri(java.lang.String uri, java.lang.Object... uriVariables)
    }
}

=== Part 8 ===
Class `com.commerce.backend.model.response.cart.CartResponse` declaration:
public class CartResponse
The class uses the following imports:
- from package com.commerce.backend.model.dto: DiscountDTO, CartItemDTO
The class has following members:
public methods:
- List<CartItemDTO> getCartItems()
- DiscountDTO getDiscount()
- Float getTotalCartPrice()
- Float getTotalCargoPrice()
- Float getTotalPrice()


=== Part 9 ===
package jakarta.persistence;
@java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.FIELD})
@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface Column {
    java.lang.String name() default ""
}

=== Part 10 ===
package io.quarkus.cli;
@CommandLine.Command(name = "create", header = "Create a new project.", subcommands = {
        CreateApp.class,
        CreateCli.class,
        CreateExtension.class })
public class Create implements Callable<Integer> {
}

=== Part 11 ===
package jakarta.persistence;
@java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.FIELD})
@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface Column {
    java.lang.String name() default ""
}

=== Part 12 ===
Class `org.springframework.samples.petclinic.visits.model.Visit` declaration:
@Entity
@Table(name = "visits")
@Builder(builderMethodName = "visit")
public class Visit
The class has following members:
public methods:
- Visit(Integer id,Date date,String description,int petId)
- Visit()
- void setId(Integer id)
- void setDate(Date date)
- void setDescription(String description)
- void setPetId(int petId)
- Integer getId()
- Date getDate()
- String getDescription()
- int getPetId()
fields:
- @Column(name = "pet_id")
    private int petId;


=== Part 13 ===
package jakarta.persistence;
@java.lang.annotation.Target({java.lang.annotation.ElementType.TYPE})
@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface Table {
    java.lang.String name() default ""
}

=== Part 14 ===
package reactor.core.publisher;
public abstract class Mono <T> implements reactor.core.CorePublisher<T> {
    static final java.util.function.BiPredicate EQUALS_BIPREDICATE;
}

=== Part 15 ===
package io.quarkus.cli;
@CommandLine.Command(name = "image", sortOptions = false, mixinStandardHelpOptions = false, header = "Build or push project container image.", subcommands = {
        Build.class, Push.class
}, headerHeading = "%n", commandListHeading = "%nCommands:%n", synopsisHeading = "%nUsage: ", optionListHeading = "%nOptions:%n")
public class Image implements Callable<Integer> {
}

=== Part 16 ===
Class `org.springframework.samples.petclinic.api.dto.VisitDetails` declaration:
public class VisitDetails
The class has following members:
public methods:
- Integer getId()
- Integer getPetId()
- String getDate()
- String getDescription()


=== Part 17 ===
package io.quarkus.cli.image;
@CommandLine.Command(name = "buildpack", sortOptions = false, showDefaultValues = true, mixinStandardHelpOptions = false, header = "Build a container image using Buildpack.", description = "%n"
        + "This command will build or push a container image for the project, using Buildpack.", footer = "%n"
                + "For example (using default values), it will create a container image using with REPOSITORY='${user.name}/<project.artifactId>' and TAG='<project.version>'.", headerHeading = "%n", commandListHeading = "%nCommands:%n", synopsisHeading = "%nUsage: ", parameterListHeading = "%n", optionListHeading = "Options:%n")
public class Buildpack extends BaseImageSubCommand {
}

=== Part 18 ===
package com.commerce.backend.dao;
@Repository
public interface ProductVariantRepository extends PagingAndSortingRepository<ProductVariant, Long>,
        JpaSpecificationExecutor<ProductVariant> {
}

=== Part 19 ===
package com.commerce.backend.service;
public interface ProductService {
}

=== Part 20 ===
package io.quarkus.cli.deploy;
@CommandLine.Command(name = "kind", sortOptions = false, showDefaultValues = true, mixinStandardHelpOptions = false, header = "Perform the deploy action on Kind.", description = "%n"
        + "The command will deploy the application on Kind.", footer = "%n"
                + "For example (using default values), it will create a Deployment named '<project.artifactId>' using the image with REPOSITORY='${user.name}/<project.artifactId>' and TAG='<project.version>' and will deploy it to the target cluster.", headerHeading = "%n", commandListHeading = "%nCommands:%n", synopsisHeading = "%nUsage: ", parameterListHeading = "%n", optionListHeading = "Options:%n")
public class Kind extends BaseKubernetesDeployCommand {
}

=== Part 21 ===
package com.commerce.backend.converter.product;
@Component
public class ProductResponseConverter implements Function<Product, ProductResponse> {
}

=== Part 22 ===
package com.commerce.backend.model.request.cart;
public class AddToCartRequest {
    @NotNull
    @Min(1)
    private Long productVariantId;
    @NotNull
    @Min(1)
    private Integer amount;
public AddToCartRequest()
public void setProductVariantId(java.lang.Long productVariantId)
public void setAmount(java.lang.Integer amount)
}

=== Part 23 ===
Class `com.commerce.backend.model.dto.DiscountDTO` declaration:
@Builder
public class DiscountDTO
The class has following members:
public methods:
- DiscountDTO(Integer discountPercent,Integer status)
- void setDiscountPercent(Integer discountPercent)
- void setStatus(Integer status)
- Integer getDiscountPercent()
- Integer getStatus()


=== Part 24 ===
Class `org.springframework.samples.petclinic.customers.model.Pet` declaration:
@Entity
@Table(name = "pets")
public class Pet
The class uses the following imports:
- from package org.springframework.samples.petclinic.customers.model: Owner, PetType
The class has following members:
public methods:
- Integer getId()
- String getName()
- Date getBirthDate()
- PetType getType()
- Owner getOwner()
fields:
- @ManyToOne
    @JoinColumn(name = "owner_id")
    @JsonIgnore
    private Owner owner;
- @Column(name = "name")
    private String name;
- @Column(name = "birth_date")
    @Temporal(TemporalType.DATE)
    private Date birthDate;
- @ManyToOne
    @JoinColumn(name = "type_id")
    private PetType type;
- @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;


=== Part 25 ===
package io.quarkus.cli.image;
@CommandLine.Command(name = "podman", sortOptions = false, showDefaultValues = true, mixinStandardHelpOptions = false, header = "Build a container image using Podman.", description = "%n"
        + "This command will build or push a container image for the project, using Podman.", footer = "%n"
                + "For example (using default values), it will create a container image using with REPOSITORY='${user.name}/<project.artifactId>' and TAG='<project.version>'.", headerHeading = "%n", commandListHeading = "%nCommands:%n", synopsisHeading = "%nUsage: ", parameterListHeading = "%n", optionListHeading = "Options:%n")
public class Podman extends BaseImageSubCommand {
}

=== Part 26 ===
package com.commerce.backend.converter.product;
@Component
public class ProductVariantResponseConverter implements Function<ProductVariant, ProductVariantResponse> {
}

=== Part 27 ===
Class `org.springframework.samples.petclinic.api.dto.PetDetails` declaration:
public class PetDetails
The class uses the following imports:
- from package org.springframework.samples.petclinic.api.dto: VisitDetails, PetType
The class has following members:
public methods:
- int getId()
- String getName()
- String getBirthDate()
- PetType getType()
- List<VisitDetails> getVisits()
fields:
- private int id;
- private final List<VisitDetails> visits = new ArrayList<>();


=== Part 28 ===
package com.commerce.backend.dao;
@Repository
public interface CartRepository extends CrudRepository<Cart, Long> {
}

=== Part 29 ===
package com.commerce.backend.service;
@Service
public class CartServiceImpl implements CartService {
    @Autowired
    public CartServiceImpl(CartRepository cartRepository,
                           ProductService productService,
                           UserService userService,
                           CartResponseConverter cartResponseConverter)
}

=== Part 30 ===
package com.commerce.backend.service;
@Service
public class ProductServiceImpl implements ProductService {
    @Autowired
    public ProductServiceImpl(ProductCacheService productCacheService,
                              ProductRepository productRepository,
                              ProductVariantRepository productVariantRepository,
                              ProductVariantCacheService productVariantCacheService,
                              ProductResponseConverter productResponseConverter,
                              ProductVariantResponseConverter productVariantResponseConverter,
                              ProductDetailsResponseConverter productDetailsResponseConverter)
}

=== Part 31 ===
package jakarta.persistence;
@java.lang.annotation.Documented
@java.lang.annotation.Target({java.lang.annotation.ElementType.TYPE})
@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface Entity {
}

=== Part 32 ===
package org.springframework.samples.petclinic.customers.model;
/**
 * Repository class for <code>Owner</code> domain objects All method names are compliant with Spring Data naming
 * conventions so this interface can easily be extended for Spring Data See here: http://static.springsource.org/spring-data/jpa/docs/current/reference/html/jpa.repositories.html#jpa.query-methods.query-creation

 */
public interface OwnerRepository extends JpaRepository<Owner, Integer> {
}

=== Part 33 ===
package com.commerce.backend.converter.user;
@Component
public class UserResponseConverter implements Function<User, UserResponse> {
}

=== Part 34 ===
package com.commerce.backend.service;
public interface CartService {
    CartResponse addToCart(Long id, Integer amount)
    CartResponse incrementCartItem(Long cartItemId, Integer amount)
    CartResponse decrementCartItem(Long cartItemId, Integer amount)
    CartResponse fetchCart()
    CartResponse removeFromCart(Long id)
    boolean confirmCart(ConfirmCartRequest confirmCartRequest)
    void emptyCart()
}

=== Part 35 ===
Class `org.springframework.samples.petclinic.api.dto.VisitDetails` declaration:
public class VisitDetails
The class has following members:
public methods:
- Integer getId()
- Integer getPetId()
- String getDate()
- String getDescription()


=== Part 36 ===
package com.commerce.backend.model.request.cart;
public class DecrementCartItemRequest {
    @NotNull
    @Min(1)
    private Long cartItemId;
    @NotNull
    @Min(1)
    private Integer amount;
public DecrementCartItemRequest()
public void setCartItemId(java.lang.Long cartItemId)
public void setAmount(java.lang.Integer amount)
}

=== Part 37 ===
package jakarta.persistence;
@java.lang.annotation.Target({java.lang.annotation.ElementType.TYPE})
@java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
public @interface Table {
    java.lang.String name() default ""
}

=== Part 38 ===
package com.commerce.backend.service;
@Service
public class UserServiceImpl implements UserService {
    @Autowired
    public UserServiceImpl(UserRepository userRepository,
                           PasswordEncoder passwordEncoder,
                           UserResponseConverter userResponseConverter)
}

=== Part 39 ===
package com.commerce.backend.service.cache;
public interface ProductCacheService {
}

=== Part 40 ===
package com.commerce.backend.service;
public interface UserService {
}

=== Part 41 ===
package com.commerce.backend.model.request.cart;
public class RemoveFromCartRequest {
    @NotNull
    @Min(1)
    private Long cartItemId;
public RemoveFromCartRequest()
public void setCartItemId(java.lang.Long cartItemId)
}

=== Part 42 ===
package com.commerce.backend.service.cache;
@Service
@CacheConfig(cacheNames = "product")
public class ProductCacheServiceImpl implements ProductCacheService {
    @Autowired
    public ProductCacheServiceImpl(ProductRepository productRepository)
}

=== Part 43 ===
package org.springframework.samples.petclinic.api.application;
@Component
public class VisitsServiceClient {
    // Could be changed for testing purpose
    private String hostname = "http://visits-service/";
    private final WebClient.Builder webClientBuilder;
    public Mono<Visits> getVisitsForPets(final List<Integer> petIds) {
        return webClientBuilder.build()
            .get()
            .uri(hostname + "pets/visits?petId={petId}", joinIds(petIds))
            .retrieve()
            .bodyToMono(Visits.class);
    }
    private String joinIds(List<Integer> petIds) {
        return petIds.stream().map(Object::toString).collect(joining(","));
    }
    void setHostname(String hostname)
public VisitsServiceClient(org.springframework.web.reactive.function.client.WebClient.Builder webClientBuilder)
}

=== Part 44 ===
package org.springframework.samples.petclinic.customers.web;

record PetDetails(

    long id,

    String name,

    String owner,

    @DateTimeFormat(pattern = "yyyy-MM-dd")
    Date birthDate,

    PetType type
) {
    public PetDetails(Pet pet) {
        this(pet.getId(), pet.getName(), pet.getOwner().getFirstName() + " " + pet.getOwner().getLastName(), pet.getBirthDate(), pet.getType());
    }
}

=== Part 45 ===
Class `com.commerce.backend.model.dto.CartItemDTO` declaration:
@Builder
public class CartItemDTO
The class uses the following imports:
- from package com.commerce.backend.model.dto: ColorDTO
The class has following members:
public methods:
- CartItemDTO(Long id,String url,String name,Float price,Integer amount,String thumb,Integer stock,ColorDTO color)
- void setId(Long id)
- void setUrl(String url)
- void setName(String name)
- void setPrice(Float price)
- void setAmount(Integer amount)
- void setThumb(String thumb)
- void setStock(Integer stock)
- void setColor(ColorDTO color)
- Long getId()
- String getUrl()
- String getName()
- Float getPrice()
- Integer getAmount()
- String getThumb()
- Integer getStock()
- ColorDTO getColor()


=== Part 46 ===
Class `com.commerce.backend.model.request.cart.ConfirmCartRequest` declaration:
public class ConfirmCartRequest
The class uses the following imports:
- from package com.commerce.backend.model.dto: DiscountDTO, CartItemDTO
The class has following members:
public methods:
- ConfirmCartRequest()
- void setCartItems(List<CartItemDTO> cartItems)
- void setDiscount(DiscountDTO discount)
- void setTotalCartPrice(Float totalCartPrice)
- void setTotalCargoPrice(Float totalCargoPrice)
- void setTotalPrice(Float totalPrice)


=== Part 47 ===
package io.quarkus.utilities;
/**
 * Enum to classify the os.name system property
 */
public enum OS {
    WINDOWS,
    LINUX,
    MAC,
    OTHER;
    public static OS determineOS() {
        final String osName = System.getProperty("os.name").toLowerCase();
        final OS os;
        if (osName.contains("windows")) {
            os = OS.WINDOWS;
        } else if (osName.contains("linux")
                || osName.contains("freebsd")
                || osName.contains("unix")
                || osName.contains("sunos")
                || osName.contains("solaris")
                || osName.contains("aix")) {
            os = OS.LINUX;
        } else if (osName.contains("mac os")) {
            os = OS.MAC;
        } else {
            os = OS.OTHER;
        }

        return os;
    }
}

=== Part 48 ===
package com.commerce.backend.model.request.cart;
public class IncrementCartItemRequest {
    @NotNull
    @Min(1)
    private Long cartItemId;
    @NotNull
    @Min(1)
    private Integer amount;
public IncrementCartItemRequest()
public void setCartItemId(java.lang.Long cartItemId)
public void setAmount(java.lang.Integer amount)
}

=== Part 49 ===
package io.quarkus.cli.image;
@CommandLine.Command(name = "jib", sortOptions = false, showDefaultValues = true, mixinStandardHelpOptions = false, header = "Build a container image using Jib.", description = "%n"
        + "This command will build or push a container image for the project, using Jib.", footer = "%n"
                + "For example (using default values), it will create a container image using with REPOSITORY='${user.name}/<project.artifactId>' and TAG='<project.version>'.", headerHeading = "%n", commandListHeading = "%nCommands:%n", synopsisHeading = "%nUsage: ", parameterListHeading = "%n", optionListHeading = "Options:%n")
public class Jib extends BaseImageSubCommand {
}

=== Part 50 ===
package io.quarkus.cli.config;
@Command(name = "encrypt", aliases = "enc", header = "Encrypt Secrets", description = "Encrypt a Secret value using the AES/GCM/NoPadding algorithm as a default. The encryption key is generated unless a specific key is set with the --key option.")
public class Encrypt extends BaseConfigCommand implements Callable<Integer> {
}

=== Part 51 ===
package io.quarkus.cli;
@CommandLine.Command(name = "categories", aliases = "cat", header = "List extension categories.")
public class ProjectExtensionsCategories extends BaseBuildCommand implements Callable<Integer> {
}

=== Part 52 ===
Class `com.commerce.backend.model.dto.ColorDTO` declaration:
@Builder
public class ColorDTO
The class has following members:
public methods:
- ColorDTO(String name,String hex)
- void setName(String name)
- void setHex(String hex)
- String getName()
- String getHex()


=== Part 53 ===
package io.quarkus.cli.deploy;
@CommandLine.Command(name = "minikube", sortOptions = false, showDefaultValues = true, mixinStandardHelpOptions = false, header = "Perform the deploy action on minikube.", description = "%n"
        + "The command will deploy the application on minikube.", footer = "%n"
                + "For example (using default values), it will create a Deployment named '<project.artifactId>' using the image with REPOSITORY='${user.name}/<project.artifactId>' and TAG='<project.version>' and will deploy it to the target cluster.", headerHeading = "%n", commandListHeading = "%nCommands:%n", synopsisHeading = "%nUsage: ", parameterListHeading = "%n", optionListHeading = "Options:%n")
public class Minikube extends BaseKubernetesDeployCommand {
}

=== Part 54 ===
package com.commerce.backend.service.cache;
public interface ProductVariantCacheService {
}

=== Part 55 ===
package org.springframework.samples.petclinic.customers.model;
/**
 * Repository class for <code>Pet</code> domain objects All method names are compliant with Spring Data naming
 * conventions so this interface can easily be extended for Spring Data See here: http://static.springsource.org/spring-data/jpa/docs/current/reference/html/jpa.repositories.html#jpa.query-methods.query-creation

 */
public interface PetRepository extends JpaRepository<Pet, Integer> {
/**
     * Retrieve all {@link PetType}s from the data store.
     * @return a Collection of {@link PetType}s.
     */
        @Query("SELECT ptype FROM PetType ptype ORDER BY ptype.name") List<PetType> findPetTypes()
    @Query("FROM PetType ptype WHERE ptype.id = :typeId") Optional<PetType> findPetTypeById(@Param("typeId") int typeId)
}

=== Part 56 ===
package com.commerce.backend.api;
@Controller
@RequestMapping("/api")
public abstract class ApiController {
}

=== Part 57 ===
package com.commerce.backend.dao;
@Repository
public interface UserRepository extends CrudRepository<User, Long> {
}

=== Part 58 ===
package org.springframework.web.reactive.function.client;
public interface WebClient {
    org.springframework.web.reactive.function.client.WebClient.RequestHeadersUriSpec<?> get()
    static interface Builder {
        org.springframework.web.reactive.function.client.WebClient build()
    }
    static interface RequestHeadersUriSpec <S extends org.springframework.web.reactive.function.client.WebClient.RequestHeadersSpec<S>> extends org.springframework.web.reactive.function.client.WebClient.UriSpec<S>, org.springframework.web.reactive.function.client.WebClient.RequestHeadersSpec<S> {
    }
    static interface ResponseSpec {
        <T> reactor.core.publisher.Mono<T> bodyToMono(java.lang.Class<T> elementClass)
    }
    static interface RequestHeadersSpec <S extends org.springframework.web.reactive.function.client.WebClient.RequestHeadersSpec<S>> {
        org.springframework.web.reactive.function.client.WebClient.ResponseSpec retrieve()
    }
    static interface UriSpec <S extends org.springframework.web.reactive.function.client.WebClient.RequestHeadersSpec<?>> {
        S uri(java.lang.String uri, java.lang.Object... uriVariables)
    }
}

=== Part 59 ===
package io.quarkus.arc.impl;
/**
 * This code was mainly copied from Weld codebase.
 */
class TypeResolver {
    private final Map<TypeVariable<?>, Type> resolvedTypeVariables;
    public TypeResolver(Map<TypeVariable<?>, Type> resolvedTypeVariables) {
        this.resolvedTypeVariables = resolvedTypeVariables;
    }
    public Map<TypeVariable<?>, Type> getResolvedTypeVariables()
}


Remember: Your response MUST be ONLY the list, e.g. [1, 3, 5]
